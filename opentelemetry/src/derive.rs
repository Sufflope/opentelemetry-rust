/// Derive conversion into [Key](struct@crate::Key).
///
/// The optional `key` attribute overrides the autogenerated key (type name, lowercased).
pub use opentelemetry_derive::Key;

/// Derive conversion into [KeyValue](struct@crate::KeyValue).
pub use opentelemetry_derive::KeyValue;

/// Derive conversion into [StringValue](struct@crate::StringValue).
pub use opentelemetry_derive::StringValue;

/// Derive conversion into [Value](enum@crate::Value).
///
/// The mandatory `variant` attribute is the intermediate type, into which your value will be converted
/// (e.g. [StringValue](struct@crate::StringValue) if your type should be represented as a string, or [i64]).
/// This variant should itself be one of the types than can be implicitly converted to [Value](enum@crate::Value).
pub use opentelemetry_derive::Value;

#[cfg(test)]
mod tests {
    extern crate self as opentelemetry;

    use std::fmt;

    use crate::{Key, KeyValue, StringValue, Value};

    #[test]
    fn test_key() {
        #[derive(Key)]
        struct Auto;

        assert_eq!(Key::from(Auto).as_str(), "auto");
        assert_eq!(Key::from(&Auto).as_str(), "auto");

        #[derive(Key)]
        #[otel(key = "custom")]
        struct Overriden;

        assert_eq!(Key::from(Overriden).as_str(), "custom");
        assert_eq!(Key::from(&Overriden).as_str(), "custom");
    }

    #[test]
    fn test_value() {
        #[derive(Value)]
        #[otel(variant = i64)]
        struct Counter {
            count: i64,
        }

        impl From<&Counter> for i64 {
            fn from(value: &Counter) -> Self {
                value.count
            }
        }

        let count = 3;
        let counter = Counter { count };

        assert_eq!(Value::from(&counter).as_str(), count.to_string());
        assert_eq!(Value::from(counter).as_str(), count.to_string());
    }

    #[test]
    fn test_string_value() {
        #[derive(StringValue)]
        enum Method {
            Get,
            Post,
        }

        impl fmt::Display for Method {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(
                    f,
                    "{}",
                    match self {
                        Self::Get => "get",
                        Self::Post => "post",
                    }
                )
            }
        }

        assert_eq!(
            StringValue::from(&Method::Get).as_str(),
            Method::Get.to_string()
        );
        assert_eq!(
            StringValue::from(Method::Post).as_str(),
            Method::Post.to_string()
        );
    }

    #[test]
    fn test_key_value() {
        #[derive(KeyValue)]
        struct Config {
            value: bool,
        }

        const KEY: &str = "config";

        impl From<&Config> for Key {
            fn from(_: &Config) -> Self {
                Self::from(KEY)
            }
        }

        impl From<&Config> for Value {
            fn from(value: &Config) -> Self {
                Value::from(value.value)
            }
        }

        let value = true;
        let config = Config { value };

        assert_eq!(KeyValue::from(&config), KeyValue::new(KEY, value));
        assert_eq!(KeyValue::from(config), KeyValue::new(KEY, value));
    }

    #[test]
    fn test_all() {
        #[derive(Key, KeyValue, StringValue, Value)]
        #[otel(key = "req", variant = StringValue)]
        struct Request {
            query: String,
        }

        impl fmt::Display for Request {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "{}", self.query)
            }
        }

        let query = "foo=bar";
        let request = Request {
            query: query.to_string(),
        };

        assert_eq!(KeyValue::from(&request), KeyValue::new("req", query));
        assert_eq!(KeyValue::from(request), KeyValue::new("req", query));
    }
}
